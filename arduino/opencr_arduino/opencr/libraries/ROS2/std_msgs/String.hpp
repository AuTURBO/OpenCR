// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file String.h
 * This header file contains the declaration of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifndef _STD_MSGS_STRING_HPP_
#define _STD_MSGS_STRING_HPP_


#include "micrortps.hpp"
#include <topic_config.h>
#include <topic.hpp>


namespace std_msgs {

class String : public ros2::Topic<String>
{
public:
  typedef char* _data_type;
  _data_type data;

  String():
    Topic("String", STD_MSGS_STRING_TOPIC),
    data(NULL)
  { 
  };


  virtual bool serialize(MicroBuffer* writer, const String* topic)
  {
      serialize_sequence_char(writer, topic->data, (uint32_t)(strlen(topic->data) + 1));
      return writer->error == BUFFER_OK;
  }

  virtual bool deserialize(MicroBuffer* reader, String* topic)
  {
      uint32_t size_data = 0;
      deserialize_sequence_char(reader, &topic->data, &size_data);
      return reader->error == BUFFER_OK;
  }


  virtual bool write(Session* session, ObjectId datawriter_id, StreamId stream_id, String* topic)
  {
      if (session == NULL)
      {
          return false;
      }

      bool result = false;
      uint32_t topic_size = size_of_topic(topic);
      MicroBuffer* topic_buffer = NULL;

      if (128 < stream_id)
      {
          topic_buffer = prepare_best_effort_stream_for_topic(&session->output_best_effort_stream, datawriter_id, topic_size);
      }
      else
      {
          topic_buffer = prepare_reliable_stream_for_topic(&session->output_reliable_stream, datawriter_id, topic_size);
      }

      if (topic_buffer != NULL)
      {
          result = serialize(topic_buffer, topic);
      }

      return result;
  }



private:

  static uint32_t size_of_topic(const String* topic)
  {
      uint32_t size = 0;

      size += 4 + get_alignment(size, 4) + (uint32_t)(strlen(topic->data) + 1);
      return size;
  }



};

} // namespace std_msgs


#endif // _STD_MSGS_STRING_HPP_
